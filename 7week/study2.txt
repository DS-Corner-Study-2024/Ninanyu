1. 리액트 컴포넌트의 라이프 사이클
리액트 컴포넌트는 태어나고 사라지는 생애주기가 있고, 이를 라이프 사이클이라고 한다. 리액트 라이프 사이클은 크게
마운트, 업데이트, 언마운트 3단계로 구분된다.
(1) 마운트(Mount): 컴포넌트를 페이지에 처음 렌더링할 떄
(2) 업데이트(Update): State나 Props의 값이 바뀌거나 부모 컴포넌트가 리렌더해 자신도 리렌더될 때
(3) 언마운트(Unmount): 더 이상 페이지에 컴포넌트를 렌더링하지 않을 때
라이프 사이클을 이용하면 컴포넌트가 처음 렌더링될 때 특정 동작을 하도록 만들거나, 업데이트할 때 적절한지 검사하거나,
페이지에서 사라질 때 메모리를 정리하는 등 여러 유용한 작업을 단계에 맞게 할 수 있다. 이를 라이프 사이클 제어라고 한다. 
리액트 훅의 하나인 함수 useEffect를 이용하면 이 사이클을 쉽게 제어할 수 있다.

2. useEffect
함수 useEffect는 어떤 값이 변경될 때마다 특정 코드를 실행하는 리액트 훅이다. 이를 "특정 값을 겁사한다"라고 표현한다.
예컨대 useEffect를 이용하면 컴포넌트의 State값이 바뀔 때마다 변경된 값을 콘솔에 출력하게 할 수 있다.

- 하나의 값 검사하기
[카운터] 앱의 App 컴포넌트에서 State 변수 count의 값이 바뀌면, 변경된 값을 콘솔에 출력하겠다.
[useEffect의 용법] useEffect(callback, [deps])

두 번째 인수로 전달한 배열을 의존성 배열(Dependency Array, 줄여서 deps)이라고 하는데, useEffect는 이 배열
요소의 값이 변경되면 첫 번째 인수로 전달한 콜백함수를 실행한다.
코드에서 useEffect의 의존성 배열 요소에 State 변수 count가 있으므로, 이 값이 바뀌면 콜백 함수가 실행된다.
콜백 함수는 콘솔에 count 업데이트라는 문자열과 함께 변경된 STate 값을 출력한다.

저장 후 개발자 콘솔을 확인-> count 업데이트: 0이 콘솔에 출력된다. 아직 State 값을 변경한 적이 없음에도 콘솔에서 문자열을
출력한 이유는 State 값을 초기화할 때도 useEffect가 이 변화를 감지하기 때문이다.
<+10>버튼을 눌러보면 버튼을 클릭할 때마다 useEffect에 인수로 전달한 콜백 함수가 실행되어, 변경된 State 값을 콘솔에 출력한다.

- 여러 개의 값 검사하기
useEffect의 의존성 배열 요소가 여러 개 있어도 마찬가지다. 즉, 배열 요소 중 하나가 변경되어도 useEffect는 콜백 함수를 실행한다.
현재 카운터 앱의 App 컴포넌트에는 State 변수 count 외에는 변경할 수 있는 값이 없다. 따라서 임시로 입력 폼을
추가하고, 이 폼에 입력한 데이터를 처리하는 text라는 이름의 State 변수를 하나 더 만들겠다. (App.js 수정)

저장 후 확인하면 입력 폼이 렌더링 되어 있는 것을 볼 수 있다.
이제 text 값이 변경되어도 useEffect가 콜백 함수를 실행해야한다. (App 컴포넌트 수정)
2개의 State 값이 변할 떄, 개발자 도구의 콘설에서 값을 출력한다.

- useEffect로 라이프 사이클 제어하기
컴포넌트의 3단계 라이프 사이클 중 업데이트가 발생하면 특정 코드를 실행하게 App 컴포넌트를 수정.
두 번째 요소인 의존성 배열에 아무것도 전달하지 않으면, useEffect는 컴포넌트를 렌더링할 때마다 콜백 함수를 실행한다. 세 번에
걸친 문자열 출력은 컴포넌트를 처음 페이지에 렌더링하는 마운트 시점 한 번과 컴포넌트를 리렌더하는 업데이트 시점 두 번의 결과다.

이번엔 useEffect에서 마운트 시점은 제외하고 업데이트 시점에만 콜백 함수를 실행하겠다. 즉, 페이지 처음 렌더링할 때는 콜백 함수를
실행하지 않고 리렌더될 때만 실행하겠다는 뜻이다. 이를 위해 함수 useRef도 사용한다. (useEffect의 콜백 함수에 조건문 추가)

정리하자면 useEffect에서 의존성 배열을 인수로 전달하지 않으면 마운트,업데이트 시점 모두 콜백 함수를 호출한다.
그러나 코드처럼 콜백 함수 내부에서 조건문과 Ref 객체로 특정 시점에만 코드를 실행하게 만들 수 있다. 즉, 마운트 시점에
호출하면 아무것도 출력하지 않고 함수를 종료하고, 업데이트 시점에 호출하면 문자열을 콘솔에 출력한다.

  useEffect(() => {
    if (!didMountRef.current){
      didMountRef.current = true;
      return;
    } else{
      console.log("컴포넌트 업데이트!");
    }
  });

  업데이트 시점에만 콘솔에 '컴포넌트 업데이트' 문자열을 출력한다.

- 컴포넌트의 마운트 제어하기
이번에는 컴포넌트의 마운트 시점에 실행되는 코드를 작성한다. 이를 "컴포넌트의 마운트를 제어한다"라고 표현한다.

App 컴포넌트는 처음에만 마운트하므로 컴포넌트 마운트 문자열은 한 번만 출력된다.

- 컴포넌트 언마운트 제어하기
라이프 사이클의 마지막 단계인 언마운트는 컴포넌트가 페이지에서 제거될 때다. 

(1) 클린업
프로그래밍에서 클린업의 개념은 특정 함수가 실행되고 종료된 후에, 미처 정리하지 못한 사항을 처리하는 일이다.
App 컴포넌트에서 함수 useEffect를 한 번 더 호출한다.
개발자 도구 콘솔을 확인하면 문자열이 깜빡이 출력되는 걸 볼 수 있다. 빠르게 연속으로 버튼을 클릭해 State값을 변경하면,
App 컴포넌트가 여러 번 리렌더 된다. 그런데 함수 setInterval에서 정한 인터벌이 나닌 매우 빠른 속도로 깜빡 문자열이
콘솔에 출력되는 현상을 볼 수 있다. 갑자기 빠르게 출력되는 이유는 두 가지 원인이 얽혀 있다.

하나는 App 컴포넌트를 렌더링할 때마다 useEffect의 콜백 함수는 새로운 setInterval 함수를 만들고 새 인터벌을 생성한다는
점이다. useEffect의 두 번째 인수로 아무것도 전달하지 않았기 때문에, 버튼을 클릭해 State를 변경하면 새 인터벌 함수를 생성한다.
또 하나는 함수 setInterval에서 인터벌을 생성한 다음에 이를 종료하지 않았기 때문이다. 인터벌을 종료하는 clearInterval이라는
또 다른 내장 함수를 호출하지 않으면 문자열 출력은 멈추지 않는다.

버튼을 클릭해 State 값을 업데이트하면 App 컴포넌트가 리렌더될 때마다 새로운 인터벌이 생성된다. 그러나 기존 인터벌을 
종료하지 않았기 떄문에 여러 개의 인터벌이 중복으로 만들어져 출력 속도가 빨라지게 된다.
이럴 때 사용하는 기능이 바로 useEffect의 클린업 기능이다.

정리하면 useEffect의 콜백 함수가 반환하는 함수를 클린업 함수라고 한다. 이 함수는 콜백 함수를 다시 호출하기 전에 실행된다.
따라서 컴포넌트를 렌더링할 때마다 새 인터벌을 생성하고 기존 인터벌은 삭제한다. useEffect의 콜백 함수가 또 다른 함수를 반환하는
클린업 기능을 이용하면 인터벌같이 종료 이후에도 남아 있는 작업을 청소할 수 있따.

- 클린업을 이용해 컴포넌트 언마운트 제어하기
컴포넌트가 페이지에서 사라질 때 원하는 코드를 실행하는 '컴포넌트 언마운트'에 대해 삺펴보자.

카운터 앱은 페이지에 렌더링한 컴포넌트를 사라지게 하는 기능이 없기 때문에 언마운트를 제어할 수 없다. 따라서 카운터 앱에
컴포넌트를 하나 새롭게 만들겠다. Even.js 컴포넌트에 count%2를 이용해 홀/짝을 구분하는 기능을 구현
-> State 값이 짝수일 때만 Even 컴포넌트를 페이지에 렌더링하여 현재 카운트는 짝수입니다라는 문자열을 표시한다.
홀수면 아무런 값도 페이지에 렌더링하지 ㅇ낳는다.

다음은 Even 컴포넌트에서 useEffect를 사용해 이 컴포넌트가 언마운트될 때 콘솔에 특정 문자열을 출력하겠다.

함수 useEffect에 의존성 배열로 빈 배열을 전달하고, 콜백 함수가 함수를 반환하면 이 함수는 컴포넌트의 언마운트 시점에서 실행된다.
State 변수 count의 초깃값은 0(짝수)이므로 App의 마운트 시점에 Even 컴포넌트 역시 마운트 된다.


3. 리액트 개발자 도구ㅎ